Loaf Language Specification v0.0.1
----------------------------------

# Background

A Cellular Automata simulation consists of a graph, a set of possible states, and rules
for transitioning between them. The simulation proceeds in discrete time intervals called
ticks. Each node is called a cell. Each cell is in a particular state. Cells transition
from one state to the next based on the state of their neighbors by following a set of rules.
Their state is updated at most once per tick.

Generally, this graph represents a one- or two-dimensional grid, with either
a Von Neumann or Moore-style neighborhood. However, the graph may be arbitrary, and need not reflect something geometric.

# Language Concepts

Loaf is almost entirely declarative; the order in which things are defined has no effect on execution. (The only
exception being the planned extension to `rules` allowing for custom attributes.)

Language primitives are in lower case. Built-in conveniences, standing in for the values assigned to blocks, are in
upper case. User-defined values are, by unenforced convention, in camel case (CamelCase).

Most statements are delimited by newlines (`\n` or `\r\n`). Collections of statements are contained within angle
brackets (`{ ... }`).

C-style comments are allowed, using `//` for single-lime comments and `/* ... */` for multiline comments. Comments are
interpreted as whitespace, meaning constructions like `neighborhood := /* comment! */ MOORE` are allowed though
discouraged.

# Blocks

A Loaf program consists of several blocks, which define the nature and rules of
the simulation. Blocks may be defined in any order.

* `features`
* `environment`
* `neighborhood`
* `boundaries`
* `states`
* `rules`

`environment`, `neighborhood`, and `boundaries` describe the environment of the simulation, and may be substituted with
different values at the start of execution via arguments. As such, they may be excluded from a Loaf program. However, if
this information is omitted entirely, the execution will fail.

`states` and `rules` provide the substance of the simulation, and must be included within the Loaf program.

## Features

`features` is a planned future block that will allow for nonstandard extensions to the language.

## Environment

The `environment` block can be used in one of two ways.

The first is to define a 1, 2, or 3 dimensional grid, using the name `nD` where `n` is the number of dimensions.
The bounds of the simulation can be optionally specified with the `x`, `y`, and `y` attributes.

`environment := 1D`

`environment := 3D::(x=100,y=100,z=10)`

`environment` can also encode an [adjacency matrix](https://en.wikipedia.org/wiki/Adjacency_matrix) between angle
brackets. These matrixes can be generated by [many tools](https://graphonline.ru/en/), and so are a convenient way for
users to supply arbitrary graphs.

Adjacency matrixes must be square (eg, have the same number of columns & rows). They consist of boolean values
represented by 0 (False - no edge) and 1 (True - edge). Spaces are delimiters for values, and newlines are delimiters
for rows.

Example:
```
environment := {
    0 1 1 0
    1 0 0 0
    1 0 0 1
    0 0 1 0
}
```

This matrix represents the graph:
```
 A <---> B
 ^
 |
 + ----> C <---> D
```

This method must be used with care, as it allows for powerful but dangerous capabilities, such as nodes connecting to
themselves, one-way connections, or orphaned nodes. Loaf will not stop you from creating such graphs, and they may be
useful to you in some circumstances. 

## Neighborhood

The `neighborhood` block defines a graph's connectivity. It can be assigned either to one of the built-in neighborhoods,
or to a series of neighborhood statements enclosed by angle-brackets.

If an adjacency matrix is used for `environment`, `neighborhood` will be ignored.

## Built-in Neighborhoods

#### Von Neumann neighborhood

`neighborhood := VON_NEUMANN`

Shorthand for the [Von Nuemann neighborhood](https://en.wikipedia.org/wiki/Von_Neumann_neighborhood).

This is equivalent to the statement:

`neighborhood := { * +- 1 }`

#### Moore Neighborhood

`neighborhood := MOORE`

Shorthand for the n-dimensional [Moore neighborhood](https://en.wikipedia.org/wiki/Moore_neighborhood).

This is equivalent to the statement:

`neighborhood := { * within 1 }`

### Neighborhood Operators

`x`, `y`, and `z` may be used refer to the first three dimensions. The alias `*` may be used to refer to all dimensions
simultaneously.

Examples:
```
neighborhood := {
    x +- 1
    y +- 1
}
```

`x + 2`

`* within 5`

#### `+` and `-` (Directed Edge operators)

#### `+-` (Undirected Edge operator)

#### `within` (Undirected Sphere operator)

This is undirected because `A within N of B` implies `B within N of A`.

#### `&` (Logical and)

Creates a directed edge if 

In order to create an undirected edge, the condition must be true from the perspective of both cells.

## Boundaries

### `void`

This is the default value for `boundaries`. The boundaries are not treated as special cases.

### `wrap`

The boundaries wrap around. In 2D, this means the environment is the surface of a toroid.

### `infinite`

There are no boundaries; cells are created as necessary.

To use the `infinite` boundary, one state must be given the `default` attribute.

### `static`

The cells at the boundary do not change state.

A state, defined in `states`, can be optionally supplied.

`boundaries := static::(Dead)`

If the state is not supplied (`boundaries := static`) then one of the states must have the `default` attribute.

## States

```
states := {
    Alive::(color="black")
    Dead::(default, color="white")
    MyState::(color=#aabbcc)
}
```

### Attributes

### The `default` attribute

## Rules
```
rules := { 
    from Dead to Alive := neighborhood(Alive) = 3
    from Alive to Dead := neighborhood(Alive) < 2 or neighborhood(Alive) > 3
}
```
### Rules Operators

#### `neighborhood(state)` (Census operator)

This operator counts the number of cells in a neighborhood (discounting the origin cell) that are in a given state.

#### `=`, `!=`, `>=`, `<=`, `<`, `>` (Comparison operators)

These operators compare two numerical value and return a boolean value.

Currently, the only numerical values are literals (eg `5`) and census results (eg `neighborhood(Alive)`).

#### `or` and `and` (Logical operators)

These operators return a boolean value based on the evaluation of two boolean expressions.

`from Alive to Dead := neighborhood(Alive) < 2 or neighborhood(Alive) > 3`

#### `()` (Parenthesis)

Parenthesis group together expressions, and return the result of that expression.

`from MyState to YourState :=
    (
        neighborhood(MyState) > neighborhood(YourState) and
        neighhorhood(TheirState) >= 1
    ) or neighborhood(TheirState) = 0`