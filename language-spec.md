Loaf Language Specification v0.0.1
----------------------------------

# Background

A Cellular Automata simulation consists of a graph, a set of possible states, and rules
for transitioning between them. The simulation proceeds in discrete time intervals called
ticks. Each node is called a cell. Each cell is in a particular state. Cells transition
from one state to the next based on the state of their neighbors by following a set of rules.
Their state is updated at most once per tick.

Generally, this graph represents a one- or two-dimensional grid, with either
a Von Neumann or Moore-style neighborhood. However, the graph may be arbitrary,
and need not reflect something geometric.

# Language Concepts

Loaf is almost entirely declarative; the order in which things are defined has no effect on execution. (The only
exception being the planned extension to `rules` allowing for custom attributes.)

Language primitives are in lower case. Built-in conveniences, standing in for the values assigned to blocks, are in
upper case. User-defined values are, by unenforced convention, in camel case (CamelCase).

Most statements are delimited by newlines (`\n` or `\r\n`). Collections of statements are contained within angle
brackets (`{ .. }`).

C-style comments are allowed, using `//` for single-lime comments and `/* ... */` for multiline comments. Comments are
interpreted as whitespace, meaning constructions like `neighborhood := /* comment! */ MOORE` are allowed though
discouraged.

# Blocks

A Loaf program consists of several blocks, which define the nature and rules of
the simulation. Blocks may be defined in any order.

* `environment`
* `neighborhood`
* `boundaries`
* `states`
* `rules`

The first three of these (`environment`, `neighborhood`, and `boundaries`)
describe the environment of the simulation, and may be substituted with
different values at runtime. As such, they may be excluded from a Loaf
program.

The latter two (`states` and `rules`) provide the substance of the
simulation, and must be included within the Loaf program.

## Environment

The `environment` block can be used in one of two ways.

The first is to define a 1, 2, or 3 dimensional grid, using the name `nD` where `n` is the number of dimensions.
The bounds of the simulation can be optionally specified with the `x`, `y`, and `y` attributes.

`environment := 1D`

`environment := 3D::(x=100,y=100,z=10)`

`environment` can also encode an [adjacency matrix](https://en.wikipedia.org/wiki/Adjacency_matrix) between angle
brackets. These matrixes can be generated by [many tools](https://graphonline.ru/en/), and so are a convenient way for
users to supply arbitrary graphs.

Adjacency matrixes must be square. They consist of boolean values represented by 0 (False - no edge) and 1
(True - edge) seperated by whitespace. Commas, tabs, and spaces are all considered valid delimiters for values, and
newlines are delimiters for rows.

Example:
```
environment := {
    0 1 1 0
    1 0 0 0
    1 0 0 1
    0 0 1 0
}
```

This matrix represents the graph:
```
 A <---> B
 ^
 |
 + ----> C <---> D
```

This method must be used with care, as it allows for powerful but dangerous capabilities, such as nodes connecting to
themselves, one-way connections, or orphaned nodes. Loaf will not stop you from creating such graphs, and they may be
useful to you in some circumstances. 

## Neighborhood

The `neighborhood` block defines a graph's connectivity. It can be assigned either to one of the built-in neighborhoods,
or to a series of neighborhood statements enclosed by angle-brackets.

If an adjacency matrix is used for `environment`, `neighborhood` will be ignored.

## Built-in Neighborhoods

#### Von Neumann neighborhood

`neighborhood := VON_NEUMANN`

Shorthand for the n-dimensional [Von Nuemann neighborhood](https://en.wikipedia.org/wiki/Von_Neumann_neighborhood).

This is equivalent to the statement:

`neighborhood := { * +- 1 }`

#### Moore Neighborhood

`neighborhood := MOORE`

Shorthand for the n-dimensional [Moore neighborhood](https://en.wikipedia.org/wiki/Moore_neighborhood).

This is equivalent to the statement:

`neighborhood := { * within 1 }`

### Neighborhood Operators

The aliases `x`, `y`, and `z` may be used. Additionally, the alias `*` may be used to refer to all dimensions.

Examples:
```
neighborhood := {
    x +- 1
    y +- 1
}
```

`x + 2`

`* within 5`

#### `+` and `-` (Directed Edge operators)

#### `+-` (Undirected Edge operator)

#### `within` (Undirected Sphere operator)

This is undirected because `A within N B` implies `B within N A`.

#### `&` (Logical and)

Creates a directed edge if 

In order to create an undirected edge, the condition must be true from the perspective of both cells.

## Boundaries

### `void`

This is the default value for `boundaries`. The boundaries are not treated as special cases.

### `wrap`

The boundaries wrap around.

### `infinite`

There are no boundaries; cells are created as necessary.

### `static`

The cells at the boundary do not change state.

A state, defined in `states`, can be optionally supplied.

`boundaries := static::Dead`

If the state is not supplied (`boundaries := static`) then one of the states must have the `default` attribute.

## States

The programmer may define up to 256 possible states.

```
states := {
    Alive::color(black)
    Dead::(default, color(white)
    MyState::color(#aabbcc)
}
```

### Attributes

### The `default` attribute

## Rules
```
rules := { 
    from Dead to Alive := neighborhood(Alive) == 3
    from Alive to Dead := neighborhood(Alive) < 2 | neighborhood(Alive) > 3
}
```
### Rules Operators

#### `neighborhood(state)` (Census operator)

This operator counts the number of cells in a neighborhood (discounting the origin cell) that are in a given state.

#### `==`, `!=`, `>=`, `<=`, `<`, `>` (Comparison operators)

These operators compare two numerical value and return a boolean value.

Currently, the only numerical values are literals (eg `5`) and census results (eg `neighborhood(Alive)`).

#### `|` and `&` (Logical operators)

These operators return a boolean value based on the evaluation of two boolean expressions.

`from Alive to Dead := neighborhood(Alive) < 2 | neighborhood(Alive) > 3`

#### `()` (Parenthesis)

Parenthesis group together expressions, and return the result of that expression.

`from MyState to YourState := ((neighborhood(MyState) > neighborhood(YourState)) & neighhorhood(TheirState) >=1) || neighborhood(TheirState) == 0`